%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

% TODO upravit odkazy

\chapter{Úvod}
%TODO Doplnit až na závěr

V~této práci se věnuji hlubokým zásobníkovým automatům konečného indexu. Snažím se omezit počet nevstupních symbolů na zásobníku a zkoumám sílu tohoto typu automatu.
Dále se zabývám ekvivalencí s~programovými gramatikami, což vede k~otázce, zda rodina jazyků přijímaná hlubokými zásobníkovými automaty konečného indexu s~jedním nevstupním 
symbolem tvoří nekonečnou hierarchii. 


\chapter{Definice}
% TODO Definice hlubokého zásobníkového automatu, programové gramatiky, maticové gramatiky. Zavedení konvencí.
% Bude třeba srovnat a doladit dle zdrojů.
% Konfigurace, sekvence, .. zavést podle IFJ slajdů.

V~této práci používám značení a pojmy z~teorie formálních jazyků zavedené například v~\cite{Meduna:Theory}. Dále vycházím z~definice maticové a programové gramatiky v~\cite{Dassow:RegulatedRewriting}.

% zavést hluboký zásobníkový automat obecný


\begin{Def} Hluboký zásobníkový automat konečného indexu je dle \cite{Meduna:DeepPDA} definován jako uspořádaná osmice $M = (Q,\Sigma,\Gamma, R, s, S, F, n)$, 
kde $Q$ je konečná množina stavů, $\Sigma$ vstupní abeceda, $\Gamma$ zásobníková abeceda, přičemž $\Sigma \subset \Gamma$,
$R$ je konečná množina pravidel, $s \in Q$ je počáteční stav, $S \in \Gamma$ počáteční symbol na zásobníku a $F \subset Q$ je množina
koncových stavů. $R$ je konečná množina pravidel typu $(m, q, A, p, v) \in \{1,2,3,\dots,n\} \times Q \times \Gamma \times Q \times {\Gamma}^*$. Zapisují se ve tvaru $mqA \rightarrow pv$. Symbol $n \in \{1,2,3,\dots\}$ označuje maximální počet nevstupních symbolů, které mohou být uložené na zásobníku.
Hloubka tohoto typu zásobníku není definovaná. Předpokládá se, že je rozšiřitelná tak, aby zásobník mohl přijmout až $n$ nevstupních symbolů.
\end{Def}

%\begin{Def}
%Bezkontextová gramatika je dle \cite{doplnit} čtveřice $G = (V,T,P,S)$, kde V je úplná abeceda, T \subset V je abeceda terminálů. Nechť N = (V - T) je abeceda neterminálů, pak S \in N je počáteční symbol. P je konečná množina pravidel, která zapisujeme ve tvaru q: A \rightarrow v, kde A \in N, v \in V^* a q je označení pravidla.

%Nechť q: A \rightarrow v \in P, x,y \in V^*, pak bezkontextová gramatika G provede derivační krok z xAy do xvy podle pravidla q; píšeme xAy \Rightarrow xvy [q] nebo zjednodušeně xAy \Rightarrow xvy. Nechť q_1, q_2, \dots q_m \in P, m \ge 0, pak G může provést sekvenci kroků dle těchto pravidel; zápisem x {\Rigtarrow}^m y [q_1 q_2 \dots q_m]. Píšeme {\Rigtarrow}^+ pro libovolné m > 0 a {\Rigtarrow}^* pro m \ge 0. Gramatika G generuje jazyk L(G), pro kteý platí, že L(G) = {w \in T^* | S {\Rigtarrow}^* w}. Jazyk L je bezkontektový, právě když L = L(G).

%\end{Def}

%\begin{Def}
%Programová gramatika je čtveřice $G = (V,T,P,S)$, která vychází z bezkontektové gramatiky. P je konečná množina pravidel tvaru q:A \rigtarrow v, g(p), kde q:A \rigtarrow definujeme stejně jako v bezkotextové gramatice a q(p) je množina značení těch pravidel, která mohou být provedena v dalším derivačním kroku.

%TODO zavést sekvence derivačních kroků
%\end{Def}

% zavést index gramatiky

% zavést maticovou gramatiku


%Pozn. Je třeba si uvědomit, že hluboký zásobníkový automat konečného indexu a gramatika konečního indexu se mají jinak definovanou svoji konečnost. Zatímco u hlubokého zásobníkového automatu nemůže nikdy dojít k tomu, že na zásobníku bude více než n nevstupních symbolů, gramatiky konečného indexu mohou expandovat řetězec s více než n neterminály. Pro každý řetězec terminálů však existuje taková sekvence derivačních kroků, která v žádném kroku neobsahuje více než n neterminálů.

\chapter{Hluboký zásobníkový automat s jedním nevstupním symbolem}
%TODO Úvod k omezení počtu nevstupních symbolů, zavedení nového typu automatu



%TODO ukázka

\section{Omezení počtu nevstupních symbolů}
% TODO Srovnání síly nového automatu s druhým typem - algoritmus

%TODO příklad převedení


Omezím-li počet nevstupních symbolů zásobníkového automatu $M$ na jeden, mohu zavést nový automat $M_\#$ a porovnat jejich sílu. Převod automatu $M$ na  $M_\#$ popisuji algoritmem \ref{alg_PDA}. Simulaci provádím pomocí stavů, do kterých ukládám informace o~původním stavu a aktuálním obsahu zásobníku. To je možné díky konečnému počtu nevstupních symbolů na zásobníku, neboť jinak by takové řešení vedlo k~nekonečnému počtu stavů.


% Algoritmus pro převod hlubokého yásobníkového automatu na ekvivalentní s omezeným počtem nevstupních szmbolů.:

\begin{Alg} \label{alg_PDA}
Převod hlubokého zásobníkového automatu konečného indexu na ekvivalentní s~jedním nevstupním symbolem.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F, n)$ 
   \item Výstup: $M_\# = (Q_\#,{\Sigma}_\#,{\Gamma}_\#, R_\#, s_\#,  S_\#, F_\#, n)$ \medskip
  
  \item ${\Sigma}_\# := \Sigma$
  \item ${\Gamma}_\# :=\{\#\} \cup \Sigma$
  \item $s_\# := <s,\#>$
  \item $S_\# := \# $ \medskip

  \item Pro každé $mqA \rightarrow pv \in R$, kde $v = b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j$, $j \in \{0,1,2,3,\dots,n\}$, $b_0,b_i \in {\Sigma}^*$ a $B_i \in (\Gamma - \Sigma)$ pro všechna $i \in \{1,2,\dots,j\}$ : \smallskip

  \subitem A~pro každé $(u,z) \in (\Gamma - \Sigma)^* \times (\Gamma - \Sigma)^*$, kde $|u|=m-1$, $|z|\le n-m$ : \smallskip

  \subsubitem přidej do $Q_\#$ stavy $<q, u A z>$, $<p, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R_\#$ pravidlo $m <q, u A z> \# \rightarrow <p, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j $,
  \subsubitem pokud $q \in F$, přidej do $F_\#$ stav $<q, u A z>$,
  \subsubitem pokud $p \in F$, přidej do $F_\#$ stav $<p, u B_1 B_2 \dots B_{j-1} B_{j} z>$.

\end{list}
\end{Alg}

Je zřejmé, že každý hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem splňuje definici pro obecný hluboký zásobníkový automat konečného indexu. Tudíž spolu s~algoritmem \ref{alg_PDA} je prokázána ekvivalence těchto automatů.


\section{Nekonečná hierarchie tříd jazyků}
% TODO Srovnání síly z programovými gramatikami - algoritmus

%TODO příklad převedení

Je dokázáno, že hluboké zásobníkové automaty konečného indexu jsou ekvivalentní s~maticovými gramatikami konečného indexu, tudíž třídy jazyků, které zásobníkový automat přijímá, tvoří nekonečnou hierarchii. \cite{Meduna:DeepPDA} Vzhledem k~výsledkům v~kapitole \ref{kap_PDA} je zřejmé, že tato vlastnost automatu zůstane i při omezení počtu nevstupních symbolů. Konstrukci důkazu tohoto tvrzení ukážu na ekvivalenci s~programovými gramatikami, přičemž je očividné, že maticové a programové gramatiky generují stejný jazyk.

Pro hluboký zásobníkový automat platí, že jestliže přijme slovo $w$, pak existuje taková komputace tohoto slova, která provádí pouze pop operace po první pop operaci. \cite{Meduna:DeepPDA} Toto tvrzení využiji v~následujícím důkazu, neboť zásobníkový automat, na kterém probíhají jen expanze funguje jako gramatika. Stačí proto ukázat, že automat je schopen na svém zásobníku simulovat všechny derivace gramatiky a opačně.


Algoritmus \ref{alg_PG} popisuje způsob, jak převést programovou gramatiku konečného indexu na hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem. Stav automatu se v~tomto případě skládá ze dvou položek: označení pravidla, které se bude simulovat v~dalším kroku, a řetězce neterminálů, které jsou na zásobníku nahrazené symbolem $\#$. Automat přejde do koncového stavu, pokud jeho zásobník neobsahuje žádné neterminály.

\begin{Alg} \label{alg_PG}
Převod programové gramatiky konečného indexu na ekvivalentní hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
  \item Vstup: $G = (T \cup N ,T,P,S)$ konečného indexu $n$
  \item Výstup: $M = (Q,\Sigma,\Gamma, R, s, S , F, n)$ \medskip
  
  \item ${\Sigma} := T$
  \item ${\Gamma} := T \cup \{\#\}$
  \item $s_\# := <\sigma>$
  \item $S_\# := \# $ \medskip

  \item Pro každé $p: S \rightarrow v, g(p) \in P$: 
  \subitem přidej do $R$ pravidlo $<\sigma>_1 \# \rightarrow <p, S> \#$ a do $Q$ stav $<p, S>$. \medskip

  \item Pro každé $q \in (Q \cup \{\epsilon\})$: 
  \subitem přidej do $F$ stav $<q, \epsilon>$. \medskip

  \item Pro každé $p: A \rightarrow v, g(p) \in P$,  kde $v=b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j$, $j \in \{0,1,2,3,\dots,n\}$, $b_0,b_i \in T^*$ a $B_i \in N$ pro všechna $i \in \{1,2,\dots,j\}$ : \smallskip
  \subitem Pro každé $(k,u,z) \in \{1,2,3,\dots,n-j+1\} \times N^* \times N^*$, kde $|u| = k-1$, $|z|  \le n-k$ : \medskip
  \subsubitem Pokud $g(p) = \emptyset$ :
  \subsubitem přidej do $Q$ stavy $<p,uAz>$, $<\epsilon, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R$ pravidlo $<p,uAz>_k \# \rightarrow <\epsilon, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j$. \medskip

  \subsubitem Jinak pro každé $q \in g(p)$:
  \subsubitem přidej do $Q$ stavy $<p,uAz>$, $<q, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R$ pravidlo $<p,uAz>_k \# \rightarrow <q, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j$.

\end{list}
\end{Alg}

Konstrukce důkazu o~převodu hlubokého zásobníkového automatu konečného indexu s~jedním nevstupním symbolem na programovou gramatiku konečného indexu je dohledatelná ve článku \cite{Krivka:RewritingSystems}, který srovnává programové gramatiky s~\#-Rewriting Systems. Programová gramatika simuluje každý krok zásobníkového automatu sekvencí několika derivací. Neterminály obsahují informace o~stavu zásobníku, aktuální pozici výskytu symbolu \# a celkovém počtu všech \# v~aktuální konfiguraci. Vlastní simulace probíhá následovně:

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
\item 1. Aktualizace pozice a celkového počtu nevstupních symbolů u~všech neterminálů.
\item 2. Expanze neterminálu na příslušné pozici.
\item 3. Odstranění pomocných stavů.
\end{list}

Tím jsem ukázala, že výše zavedený typ zásobníkového automatu je ekvivalentní s~programovými gramatikami. Z~toho vyplývá, že rodina jazyků přijímaná tímto zásobníkovým automatem tvoří nekonečnou hierarchii vycházející s~programových gramatik.


\chapter{Závěr}
%TODO Dolnit až na konec
% Závěrečná kapitola obsahuje zhodnocení dosažených výsledků se zvlášť vyznačeným vlastním přínosem studenta. Povinně se 
% zde objeví i zhodnocení z pohledu dalšího vývoje projektu, student uvede náměty vycházející ze zkušeností s řešeným 
% projektem a uvede rovněž návaznosti na právě dokončené projekty.

V~tomto příspěvku jsem dokázala, že hluboký zásobníkový automat konečného indexu omezením počtu nevstupních symbolů neztrácí na své síle. Následně jsem ukázala ekvivalenci tohoto typu automatu s~programovými gramatikami konečného indexu. Z~toho vyplývá, že rodiny jazyků, které tento automat přijímá, tvoří nekonečnou hierarchii.


%=========================================================================
