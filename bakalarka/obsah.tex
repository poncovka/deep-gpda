%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Úvod}
%TODO Doplnit až na závěr



%=========================================================================
%\subsubsection{Hluboký zásobníkový automat}


%=========================================================================
%\subsubsection{Hierarchie mezi kontextovými a bezkontextovými jazyky}
% význam, aplikace


%=========================================================================
%\subsubsection{Redukce v gramatikách a automatech}
% proč se redukuje

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Použité pojmy a definice}
% TODO Definice hlubokého zásobníkového automatu, programové gramatiky, maticové gramatiky. Zavedení konvencí.

\begin{Def} Hluboký zásobníkový automat konečného indexu je dle \cite{Meduna:DeepPDA} definován jako uspořádaná osmice $M = (Q,\Sigma,\Gamma, R, s, S, F, n)$, kde 
$Q$ je konečná množina stavů, 
$\Sigma$ vstupní abeceda, 
$\Gamma$ zásobníková abeceda, přičemž $\Sigma \subset \Gamma$,
$R$ je konečná množina pravidel, 
$s \in Q$ je počáteční stav, 
$S \in \Gamma$ počáteční symbol na zásobníku a 
$F \subset Q$ je množina koncových stavů. 
$R$ je konečná množina pravidel typu $(m, q, A, p, v) \in \{1,2,3,\dots,n\} \times Q \times (\Gamma-\Sigma) \times Q \times {\Gamma}^+$. Zapisují se ve tvaru $mqA \rightarrow pv$. Symbol $n \in \{1,2,3,\dots\}$ označuje maximální počet nevstupních symbolů, které mohou být uložené na zásobníku.
Hloubka tohoto typu zásobníku není definovaná. Předpokládá se, že je rozšiřitelná tak, aby zásobník mohl přijmout až $n$ nevstupních symbolů.
\end{Def}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Hluboký zásobníkový automat s~jedním nevstupním symbolem}
%TODO Úvod k omezení počtu nevstupních symbolů, zavedení nového typu automatu


%=========================================================================
\section{Omezení počtu nevstupních symbolů}\label{section_deep_pda_nonterm}
% TODO Srovnání síly nového automatu s druhým typem - algoritmus

Omezím-li počet nevstupních symbolů zásobníkového automatu $M$ na jeden, mohu zavést nový automat $M_\#$ a zkoumat jeho sílu. Převod automatu $M$ na  $M_\#$ popisuji algoritmem \ref{alg_PDA}. Pro účely simulace zavádím nové stavy, kde uchovávám informace o stavu automatu a nahrazeném obsahu zásobníku. To je možné díky konečnému počtu nevstupních symbolů na zásobníku, neboť jinak by takové řešení vedlo k~nekonečnému počtu stavů. Každé pravidlo pak lze snadno převést na jeho ekvivalent nahrazením nevstupních symbolů symbolem $\#$ a jejich uložením do stavu.

\begin{Alg} \label{alg_PDA}
Převod hlubokého zásobníkového automatu konečného indexu na ekvivalentní s~jedním nevstupním symbolem.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F, n)$ 
   \item Výstup: $M_\# = (Q_\#,{\Sigma}_\#,{\Gamma}_\#, R_\#, s_\#,  S_\#, F_\#, n)$ \medskip
  
  \item ${\Sigma}_\# := \Sigma$
  \item ${\Gamma}_\# :=\{\#\} \cup \Sigma$
  \item $s_\# := <s,\#>$
  \item $S_\# := \# $ \medskip

  \item Pro každé $mqA \rightarrow pv \in R$, kde $v = b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j$, $j \in \{0,1,2,3,\dots,n\}$, $b_0,b_i \in {\Sigma}^*$ a $B_i \in (\Gamma - \Sigma)$ pro všechna $i \in \{1,2,\dots,j\}$ : \smallskip

  \subitem A~pro každé $(u,z) \in (\Gamma - \Sigma)^* \times (\Gamma - \Sigma)^*$, kde $|u|=m-1$, $|z|\le n-m$ : \smallskip

  \subsubitem přidej do $Q_\#$ stavy $<q, u A z>$, $<p, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R_\#$ pravidlo $m <q, u A z> \# \rightarrow <p, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j $,
  \subsubitem pokud $q \in F$, přidej do $F_\#$ stav $<q, u A z>$,
  \subsubitem pokud $p \in F$, přidej do $F_\#$ stav $<p, u B_1 B_2 \dots B_{j-1} B_{j} z>$.

\end{list}
\end{Alg}

Je zřejmé, že každý hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem splňuje definici pro obecný hluboký zásobníkový automat konečného indexu. Tudíž spolu s~algoritmem \ref{alg_PDA} jsem ukázala ekvivalenci těchto automatů.

%=========================================================================
\section{Ekvivalence s~programovými gramatikami konečného indexu}
% TODO Srovnání síly z programovými gramatikami - algoritmus

%TODO příklad převedení

V~\cite{Meduna:DeepPDA} je dokázáno, že hluboké zásobníkové automaty konečného indexu jsou ekvivalentní s~maticovými gramatikami konečného indexu, tudíž třídy jazyků, které zásobníkový automat přijímá, tvoří nekonečnou hierarchii. Vzhledem k~výsledkům v~kapitole \ref{section_deep_pda_nonterm} lze očekávat, že tato vlastnost automatu zůstane i při omezení počtu nevstupních symbolů. Konstrukci důkazu tohoto tvrzení ukážu na ekvivalenci s~programovými gramatikami, přičemž je očividné, že maticové a programové gramatiky konečného indexu generují stejný jazyk (viz \cite{Dassow:RegulatedRewriting}).

Pro hluboký zásobníkový automat dle \cite{Meduna:DeepPDA} platí, že jestliže přijme nějaké slovo $w$, pak existuje taková komputace tohoto slova, která provádí pouze pop operace po první pop operaci. Toto tvrzení využiji v~následujícím důkazu, neboť zásobníkový automat, na kterém probíhají jen expanze funguje jako gramatika. Stačí proto ukázat, že automat je schopen na svém zásobníku simulovat všechny derivace gramatiky a opačně.

Pomocí algoritmu \ref{alg_PG} popisuji způsob, jakým lze převést programovou gramatiku konečného indexu na hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem. Stav automatu se v~tomto případě skládá ze dvou položek: označení pravidla, které se bude simulovat v~dalším kroku, a řetězce neterminálů, které jsou na zásobníku nahrazené symbolem $\#$. Automat přejde do koncového stavu, pokud jeho zásobník neobsahuje žádné neterminály.
 %%%

\begin{Alg} \label{alg_PG}
Převod programové gramatiky konečného indexu na ekvivalentní hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
  \item Vstup: $G = (T \cup N ,T,P,S)$ konečného indexu $n$
  \item Výstup: $M = (Q,\Sigma,\Gamma, R, s, S , F, n)$ \medskip
  
  \item ${\Sigma} := T$
  \item ${\Gamma} := T \cup \{\#\}$
  \item $s_\# := <\sigma>$
  \item $S_\# := \# $ \medskip

  \item Pro každé $p: S \rightarrow v, g(p) \in P$: 
  \subitem přidej do $R$ pravidlo $<\sigma>_1 \# \rightarrow <p, S> \#$ a do $Q$ stav $<p, S>$. \medskip

  \item Pro každé $q \in (Q \cup \{\varepsilon\})$: 
  \subitem přidej do $F$ stav $<q, \varepsilon>$. \medskip

  \item Pro každé $p: A \rightarrow v, g(p) \in P$,  kde $v=b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j$, $j \in \{0,1,2,3,\dots,n\}$, $b_0,b_i \in T^*$ a $B_i \in N$ pro všechna $i \in \{1,2,\dots,j\}$ : \medskip
  \subitem Pro každé $(k,u,z) \in \{1,2,3,\dots,n-j+1\} \times N^* \times N^*$, kde $|u| = k-1$, $|z|  \le n-k$ : \medskip
  \subsubitem Pokud $g(p) = \emptyset$ :
  \subsubitem přidej do $Q$ stavy $<p,uAz>$, $<\varepsilon, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R$ pravidlo $<p,uAz>_k \# \rightarrow <\varepsilon, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j$.\medskip
  \subsubitem Jinak pro každé $q \in g(p)$:
  \subsubitem přidej do $Q$ stavy $<p,uAz>$, $<q, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R$ pravidlo $<p,uAz>_k \# \rightarrow <q, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j$.

\end{list}
\end{Alg}

Konstrukce důkazu o~převodu hlubokého zásobníkového automatu konečného indexu s~jedním nevstupním symbolem na programovou gramatiku konečného indexu je dohledatelná ve článku \cite{Krivka:RewritingSystems}, který srovnává programové gramatiky s~\#-Rewriting Systems. Programová gramatika simuluje každý krok zásobníkového automatu sekvencí několika derivací. Neterminály obsahují informace o~stavu zásobníku, aktuální pozici výskytu symbolu \# a celkovém počtu všech \# v~aktuální konfiguraci. Vlastní simulace probíhá následovně:

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
\item 1. Aktualizace pozice a celkového počtu nevstupních symbolů u~všech neterminálů.
\item 2. Expanze neterminálu na příslušné pozici.
\item 3. Odstranění pomocných stavů.
\end{list}

Tím jsem ukázala, že výše zavedený typ zásobníkového automatu je ekvivalentní s~programovými gramatikami. Z~toho vyplývá, že rodina jazyků přijímaná tímto zásobníkovým automatem tvoří nekonečnou hierarchii vycházející z~programových gramatik.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Hluboký zásobníkový automat v~normální formě}

V této kapitole zavádím normální formu hlubokého zásobníkového automatu a ukazuji způsob, jakým lze automat na tuto formu převést. Vycházím z myšlenky automatu s jedním nevstupním symbolem, kterému jsem se věnovala doposud. Hluboký zásobníkový automat je ale zobecněním konečného a nemá omezení pro počet nevstupních symbolů na zásobníku. Z toho důvodu není možné na něj aplikovat algoritmus \ref{alg_PDA}, neboť by to vedlo k nekonečnému počtu stavů a pravidel. Je ale možné pracovat podobným způsobem s tzv. prefixem zásobníku, kdy nejvrchnějších $n$ nevstupních symbolů nahrazuji symbolem $\#$. Celkový počet nevstupních symbolů jsem tak nijak nezredukovala, ale docílila jsem zjednodušeného zápisu pravidel.

% definice
% algoritmus
% ekvivalence

%=========================================================================
\section{Definice normální formy}

\begin{Def}\label{def_NF}
Nechť $M = (Q,\Sigma,\Gamma, R, s, S , F)$ je hluboký zásobníkový automat
a $n$ je maximální hloubka expanze v~$M$.
Pak $M$ je v~normální formě, pokud každé pravidlo z~$R$ je v~jednom ze tvarů:

\begin{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

\item $mqA \rightarrow p\#$, kde $A \in (\Gamma - \Sigma)$, $1 \le m \le n$, $p$, $q \in Q$,
\item $mq\# \rightarrow p\#$, kde $1 \le m \le n$, $p$, $q \in Q$,
\item $mq\# \rightarrow pa$, kde $a \in {\Sigma}^+$, $1 \le m \le n$, $p$, $q \in Q$,
\item $mq\# \rightarrow p\#A$, kde $A \in (\Gamma - \Sigma)$, $1 \le m \le n$, $p$, $q \in Q$.

\end{enumerate}

\end{Def}
\medskip
Hluboký zásobníkový automat v normální formě dle definice \ref{def_NF} pracuje s prefixem $n$ nevstupních symbolů. Přepis symbolů v prefixu na symbol $\#$ umožňuje pravidlo typu (i), změnu stavu pravidlo (ii), přepis na symbol vstupní abecedy pravidlo typu (iii) a expandovat lze pravidlem typu (iv). Nechť pravidlo typu (iv) je možné aplikovat jen na nejspodnější symbol $\#$, pak na zásobníku je v každém kroku derivace řetězec z množiny $ ( \Sigma^* \{ \# \} )^k  \Gamma^*$, kde $0 \le k \le n$. 

\section{Převod na normální formu}

Při sestavování algoritmu pro převod hlubokého zásobníkového automatu do normální formy jsem musela řešit zejména omezené možnosti expanze. Původní stav automatu a nevstupní symboly z prefixu opět uchovávám ve stavech. Pokud bych ale připustila expanzi na libovolný počet nevstupních symbolů, ztratila bych ze stavu informaci o nahrazených nevstupních symbolech, které by se ocitly za prefixem, nebo bych zvětšovala velikost prefixu a počet pomocných stavů by tak narostl do nekonečna. Tento problém jsem vyřešila tzv. postupnou expanzí. Pravá strana pravidla je reprezentovaná jedním nevstupním symbolem. Ten je možné expandovat na právě dva nevstupní symboly: první symbol v řetězci a zbytek řetězce. Jednoduchou rekurzí tohoto postupu lze dosáhnout úplné expanze.

Expanze na dva nevstupní symboly je již udržitelná, ale stále se může stát, že poslední symbol $\#$ bude odsunut o jednu pozici za prefix. Nabízí se povolit pravidlo pro přepis tohoto symbolu na původní nevstupní symbol, ale tím bych zvýšila hloubku automatu. Místo toho spojuji krok expanze a krok přepisu posledního $\#$ symbolu na původní symbol do jednoho pravidla typu (iv). Expanze tak nemá vliv na $\#$ symboly v prefixu.

V algoritmu \ref{alg_NF} popisuji konstrukci hlubokého zásobníkového automatu v normální formě. S ohledem na postupnou expanzi zavádím nové nevstupní symboly, jejichž součástí je rovněž původní pravidlo pro expanzi. Nelze určit dopředu, kdy se jednotlivé kroky expanze provedou, proto je nutné je umožnit provést ve všech stavech automatu a na všech pozicích v prefixu. 

\begin{Alg}\label{alg_NF}
Převod hlubokého zásobníkového automatu do normální formy.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F)$ 
   \item Výstup: $M_{NF} = (Q_{NF}, \Sigma_{NF}, {\Gamma}_{NF}, R_{NF}, s_{NF},  S_{NF}, F_{NF})$ \medskip
  
  \item ${\Sigma}_{NF} := \Sigma$
  \item ${\Gamma}_{NF} :=\{\#\} \cup \Sigma$
  \item $s_{NF} := <s,S>$
  \item $S_{NF} := \#$ \medskip

  \item $k := \mathrm{max}(\{m \mid mqA \rightarrow pv \in R\}) $ \medskip

  \item Pro každé $(q,u,A) \in Q \times (\Gamma - \Sigma)^* \times (\Gamma - \Sigma)$, kde $|u| < k$: \medskip

  \subitem přidej do $R_{NF}$ pravidlo typu (i) $|uA| <q,u> A \rightarrow <q,uA> \#$. \medskip

  \item Pro každé $r : mqA \rightarrow p X_1 X_2 X_3 \dots X_j \in R$, kde $1 \le i \le j$, $X_i \in \Gamma$, a 
         pro každou dvojici $(u,v) \in (\Gamma - \Sigma)^* \times (\Gamma - \Sigma)^*$, kde $|uv| < k$ : \medskip

  \subitem Pokud $|u| = m - 1$, $|v| \le k-m$, přidej do $R_{NF}$ pravidlo typu (ii) :
  \subitem $m <q,uAv> \# \rightarrow <p,u (r : X_1 X_2 X_3 \dots X_j) v>\#$ . \medskip

  \subitem Pro každé $(X_i,q') \in \{X_1, X_2, X_3, \dots, X_j\} \times Q$: \medskip

  \subsubitem Pokud $X_i \in (\Gamma - \Sigma)$, přidej do $R_{NF}$ pravidlo typu (ii) :
  \subsubitem $|u|+1 <q',u (r : X_i) v> \# \rightarrow <q',u X_i v> \# $. \medskip

  \subsubitem Pokud $X_i \in \Sigma$, přidej do $R_{NF}$ pravidlo typu (iii) :
  \subsubitem $|u|+1 <q',u (r : X_i) v> \# \rightarrow <q',uv> X_i $.\medskip

  \subsubitem Pokud $i < j$, přidej do $R_{NF}$ pravidlo typu (iv) :

  \subsubitem $|uv|+1 <q',u(r : X_i X_{i+1} \dots X_j)v> \# \rightarrow <q',u(r : X_i) (r: X_{i+1} \dots X_j)v'>\# V' $
  \subsubitem pro $v \ne \varepsilon$, kde $v = V_1 V_2 V_3 \dots V_{l-1} V_l$, $v' = V_1 V_2 V_3 \dots V_{l-1}$ a $V'=V_l$, jinak
  \subsubitem $|u|+1 <q',u(r : X_i X_{i+1} \dots X_j)> \# \rightarrow <q',u(r : X_i)>\# (r: X_{i+1} \dots X_j)$.\bigskip

  \item $Q_{NF} := \{p,q \mid mqA \rightarrow pv \in R_{NF}\} $
  \item $F_{NF} := \{<q, \varepsilon> \mid  q \in F \}$


\end{list}
\end{Alg}

%=========================================================================
%\section{Ekvivalence s~...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Zobecněný hluboký zásobníkový automat}

% Definice

\begin{Def}
Zobecněný hluboký zásobníkový automat je uspořádaná sedmice $M = (Q,\Sigma,\Gamma, R, s, S, F)$, 
kde $Q$ je konečná množina stavů, $\Sigma$ vstupní abeceda, $\Gamma$ zásobníková abeceda, přičemž $\Sigma \subset \Gamma$,
$s \in Q$ je počáteční stav, $S \in \Gamma$ počáteční symbol na zásobníku a $F \subset Q$ je množina
koncových stavů. $R$ je konečná množina pravidel typu $(q, A, p, v) \in Q \times (\Gamma - \Sigma) \times Q \times {\Gamma}^+$, které píšeme ve tvaru $qA \rightarrow pv$. 
\end{Def}

\begin{Def}
Nechť $M = (Q,\Sigma,\Gamma, R, s, S, F)$ je zobecněný hluboký zásobníkový automat, $(w,q,uAz)$ a $(w,p,uvz)$ jeho dvě konfigurace a $qA \rightarrow pv \in R$ pravidlo. Pak lze provést přechod z~$(w,q,uAz)$ do $(w,p,uvz)$, píšeme $(w,q,uAz) {\Rightarrow} (w,p,uvz)$, právě tehdy když platí: $\{X \mid qX \rightarrow p'v' \in R$, kde $X \in \mathrm{alph}(u) \cap (\Gamma - \Sigma)$, $p' \in Q$, $v' \in {\Gamma}^+ \} = \emptyset$.
\end{Def}

%=========================================================================
 \section{Ekvivalence se stavovými gramatikami} \label{sec_ekv_state_grammars}

% ekvivalence se stavovými gramatikami, povolení epsilon pravidel, co s toho vyplývá
% algoritmus a důkaz

%=========================================================================
\section{Omezení počtu nevstupních symbolů}

% odkaz na článek on state grammars, co s toho vyplývá
% algoritmus

Ve článku \ref{DOPLNIT} je dokázáno, že každá stavová gramatika s~$\varepsilon$-pravidly lze má svůj ekvivalentní protějšek se třemi nevstupními symboly. S ohledem na výsledek kapitoly \ref{sec_ekv_state_grammars} je na místě prozkoumat, zda lze takové redukce dosáhnout i u zobecněných hlubokých automatů.

V algoritmu \ref{alg_gen_deep_pda_nonterm} demonstruji redukci nevstupních symbolů na symboly 0, 1 a \#. Hlavní myšlenka spočívá v reprezentaci všech zásobníkových symbolů pomocí nul a jedniček. Symbol \# označuje fyzické dno zásobníku a umožňuje přesouvat symboly z vrcholu na jeho konec. Zároveň k symbolu \# zavádím binární ekvivalent, který označuje logické dno zásobníku. 

Princip simulace spočívá v rozpoznání symbolu na vrcholu zásobníku pomocí pravidel z množiny $R_{find}$ a jeho přesun na dno zásobníku, případně expanze pravidlem z $R_{exp}$. Pokud dojde k expanzi, aplikují se pravidla s množiny $R_{copy}$, které přesunou zbývající symboly na dno. Pokud pro žádný nevstupní symbol v zásobníku expanze neproběhne, automat nahradí binární reprezentace vstupních symbolů samotnými symboly pomocí pravidel z množiny $R_{\Sigma}$, smaže pomocné nevstupní symboly a přejde do koncového stavu.

\begin{Alg}\label{alg_gen_deep_pda_nonterm}
Převod zobecněného hlubokého zásobníkového automatu s~$\varepsilon$-pravidly na ekvivalentní se třemi nevstupními symboly.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F)$ 
   \item Výstup: $M_{R} = (Q_{R}, \Sigma_{R}, {\Gamma}_{R}, R_{R}, s_{R},  S_{R}, F_{R})$ \medskip
  
   \item ${\Sigma}_{R} := \Sigma$
   \item ${\Gamma}_{R} := \Sigma \cup \{0,1,\#\}$
   \item $R_{R} := R_{find} \cup R_{exp} \cup R_{copy} \cup R_{\Sigma}$
   \item $s_{R} := <start> $
   \item $S_{R} := \# $
   \item $F_{R} := \{<end>\} $ \medskip

\medskip

  \item Nechť $\Gamma = \{X_1, X_2, X_3, \dots, X_n\}$ pro $n \ge 1$ je množina všech zásobníkových symbolů v $M$ a $X_0$ značí symbol $\#$. Pak definujme funkci $\varphi : \Gamma \cup \{\#\} \rightarrow \{0,1\}^*$ tak, že $\varphi (X_i)=0^i 1$ pro $i = 0,1,2,\dots,n$. \medskip

  \item Přidej do $Q_R$ pro každé $q \in Q$, $0 \le i \le n$ stavy:
  \item $<start>$, $<q, 0^i>$, $<q, 0^i 1>$, $<q, 0^i>'$, $<q, 0^i 1>'$, $<q, 0^i>''$, $<q, 0^i 1>''$, $<end>$.\medskip

  \item Pro každé $qA \rightarrow p B_0 B_1 \dots B_{j-1} B_{j} \in R$, kde $p, q \in Q$, $j \ge 0$, $B_0,B_1,\dots,B_j \in \Gamma$ a $A \in (\Gamma - \Sigma)$, 
          přidej $<q, \varphi (A)>$ do množiny $Q_{exp}$  a do $R_{exp}$ pravidla:

\begin{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<start> \# \rightarrow <s, \varepsilon> \varphi(S)\varphi(\#)\#$,
  \item $<q, \varphi (A)> \# \rightarrow <p, \varepsilon>' \varphi(B_0)\varphi(B_1)\varphi(B_2) \dots \varphi(B_{j-1}) \varphi(B_{j}) \#$.

\suspend{enumerate}

  \item Pro každé $q \in Q$, $0 \le i \le n$ přidej do $R_{find}$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<q, 0^i> 0 \rightarrow <q, 0^{i+1}> \varepsilon $, $<q, 0^i> 1 \rightarrow <q, 0^i 1> \varepsilon $,
  \item $<q, 0^i>' 0 \rightarrow <q, 0^{i+1}>' \varepsilon $, $<q, 0^i>' 1 \rightarrow <q, 0^i 1>' \varepsilon $
  \item $<q, 0^i>'' 0 \rightarrow <q, 0^{i+1}>'' \varepsilon $, $<q, 0^i>'' 1 \rightarrow <q, 0^i 1>'' \varepsilon $.

\suspend{enumerate}


  \item Přidej do $R_{next}$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<q, \varphi(X)> \# \rightarrow <q, \varepsilon> \varphi(X) \# $, kde $X \in \Gamma$, $q \in Q$, $<q, \varphi(X)> \notin Q_{exp}$,
  \item $<q, \varphi(\#) > \# \rightarrow <q, \varepsilon>'' \varphi(\#) \# $, kde $q \in Q$.

\suspend{enumerate}

  \item Přidej do $R_{move}$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<q, \varphi(X)>' \# \rightarrow <q, \varepsilon>' \varphi(X) \# $, kde $X \in \Gamma$, $q \in Q$,
  \item $<q, \varphi(\#) >' \# \rightarrow <q, \varepsilon> \varphi(\#) \# $, kde $q \in Q$.

\suspend{enumerate}

  \item Přidej do $R_{end}$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<q, \varphi(X) >'' \# \rightarrow <q, \varepsilon>'' X \# $, kde $X \in \Sigma$, $q \in Q$,
  \item $<q, \varphi(X) >'' \# \rightarrow <q, \varepsilon>'' \varphi(X) \# $, kde $X \in (\Gamma - \Sigma)$, $q \in Q$,
  \item $<q, \varphi(\#) >'' \# \rightarrow <end> \epsilon $, kde $q \in Q$.

\end{enumerate}

\end{list}
\end{Alg}



%=========================================================================
\section{Omezení počtu stavů}

% odkaz na článek on state grammars
% algoritmus

\begin{Alg}
Převod zobecněného hlubokého zásobníkového automatu s~$\varepsilon$-pravidly na ekvivalentní s redukcí na tři stavy.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F)$ 
   \item Výstup: $M_{R} = (Q_{R}, \Sigma_{R}, {\Gamma}_{R}, R_{R}, s_{R},  S_{R}, F_{R})$ \medskip

   \item ${\Sigma}_{R} := \Sigma$
   \item ${\Gamma}_{R} := \Sigma \cup {\Gamma}_{R}'$
   \item $Q_{R} := \{s_\alpha, s_\beta, s_\gamma \}$
   \item $R_{R} := R_{\alpha} \cup R_{\beta} \cup R_{\gamma}$
   \item $s_{R} := s_{\alpha} $
   \item $S_{R} := <start> $
   \item $F_{R} := \{s_{\alpha}\} $ \medskip

   \item Nechť $Q = \{s_0, s_1, s_2, \dots,s_{|Q|}\}$, kde $s_0 = s$ je počáteční stav v~$M$. Nechť $s_{|Q|+1} = s_0$.\medskip

   \item Pro každé $qA \rightarrow p b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j \in R$, kde $p, q \in Q$, $j \ge 0$, $b_0,b_1,\dots,b_j \in {\Sigma}^*$ a $A, B_1,B_2,\dots,B_j \in (\Gamma - \Sigma)$. 
         Nechť $k$ je absolutní hodnota rozdílu indexů stavů $p$ a $q$. 
         Pak přidej do $R_\alpha$ pravidla:

\begin{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

   \item $s_\alpha <start> \rightarrow s_\alpha <s_0, S> <s_0, \#>$,
   \item  $s_\alpha <q, A> \rightarrow s_\alpha b_0 <q, B_1> b_1 <q, B_2> b_2 \dots b_{j-1} <q, B_j> b_j$ pokud $p = q$,
   \item  $s_\alpha <q, A> \rightarrow s_\beta <k> b_0 <q, B_1> b_1 <q, B_2> b_2 \dots b_{j-1} <q, B_j> b_j$ pro $p \ne q$. 

\suspend{enumerate}

   \item Přidej do $R_\beta$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

   \item $s_\beta <s_i, X> \rightarrow s_\beta <s_{i+1}, X>'$ pro každé $s_i \in Q$ a každé $X \in (\Gamma - \Sigma)$,
   \item $s_\beta <s_i, \#> \rightarrow s_\alpha <s_{i+1}, \#>_{set}$ pro každé $s_i \in Q$.

\suspend{enumerate}

   \item Přidej do $R_\alpha$ pravidla:

\resume{enumerate}{\setlength\leftmargin{1em}}
\renewcommand{\labelenumi}{(\roman{enumi})}

   \item $s_\alpha <j> \rightarrow s_\gamma <j - 1 > $ pro každé $j \in \{2,3,\dots,|Q|\}$,
   \item $s_\alpha <1> \rightarrow s_\alpha \varepsilon $,
   \item $s_\alpha <s_i, \#>_{set} \rightarrow s_\gamma <s_{i}, \#>_{exp}$ pro každé $s_i \in Q$,
   \item $s_\alpha <q, \#> \rightarrow s_\alpha \varepsilon $ pro každé $q \in F$.

\suspend{enumerate}{\setlength\leftmargin{1em}}

   \item Přidej do množiny $R_\gamma$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

   \item $s_\gamma <s_i, X>' \rightarrow s_\gamma <s_i, X> $ pro každé $s_i \in Q$ a každé $X \in (\Gamma - \Sigma)$,
   \item $s_\gamma <s_i, \#>_{set} \rightarrow s_\beta <s_i, \#>$ pro každé $s_i \in Q$,
   \item $s_\gamma <s_i, \#>_{exp} \rightarrow s_\alpha <s_{i}, \#>$ pro každé $s_i \in Q$.

\end{enumerate}

   \item Pro každé $q \in Q$, $X \in (\Gamma - \Sigma)$, $j \in \{1,2,3,\dots,|Q|\}$ přidej do ${\Gamma}_{R}'$ symboly :
   \item $<start>, <j>, <q, X>, <q, X>', <q, \#>, <q, \#>_{set}, <q, \#>_{exp}$.\medskip

\end{list}
\end{Alg}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Aplikace \texttt{deeppda}}
\chapter{Aplikace}

\section{Návrh}

\section{Implementace}

\section{Uživatelská příručka}

\section{Ukázka vstupů a výstupů}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Závěr}
%TODO Dolnit až na konec



%=========================================================================
