%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Úvod}
%TODO Doplnit až na závěr



%=========================================================================
%\subsubsection{Hluboký zásobníkový automat}


%=========================================================================
%\subsubsection{Hierarchie mezi kontextovými a bezkontextovými jazyky}
% význam, aplikace


%=========================================================================
%\subsubsection{Redukce v gramatikách a automatech}
% proč se redukuje

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Pojmy a definice}

V~této kapitole zavádím a definuji pojmy, ze kterých vycházím v~dalších částech své práce. Ve stručnosti se zabývám problematikou řízených gramatik a definuji programové, maticové a stavové gramatiky. Dále uvádím definici hlubokého zásobníkového automatu a jeho modifikace s~konečným indexem. Nakonec zařazuji jazyky přijímané těmito automaty spolu s~jazyky generovanými řízenými gramatikami do kontextu označovaném jako hierarchie mezi kontextovými a bezkontextovými jazyky.

%=========================================================================
\section{Základní pojmy z~teorie formálních jazyků}


%=========================================================================
\section{Hluboké zásobníkové automaty}

% DEFINICE: DEEP PDA

\begin{Def} \label{def_deep_pda}
\emph{Hluboký zásobníkový automat} je dle \cite{Meduna:DeepPDA} definován jako uspořádaná sedmice $M = (Q,\Sigma,\Gamma, R, s, S, F)$, kde 
  $Q$ je konečná množina stavů, 
  $\Sigma$ vstupní abeceda, 
  $\Gamma$ zásobníková abeceda, přičemž $\Sigma \subseteq \Gamma$ a $Q \cap \Gamma = \emptyset$,
  $R$ je konečná množina pravidel typu $(m, q, A, p, v) \in (\{1,2,3,\dots\} \times Q \times (\Gamma-\Sigma)\times   Q \times {\Gamma}^+$), píšeme $mqA \rightarrow pv$,
  $s \in Q$ je počáteční stav, 
  $S \in \Gamma$ počáteční zásobníkový symbol a 
  $F \subseteq Q$ je množina koncových stavů.

%% Definice konfigurace, derivace
Konfigurace automatu $M$ je prvek z~množiny $(Q \times \Sigma^* \times \Gamma^*)$. 
Nechť $X$, $Y$ jsou dvě konfigurace. 
$M$ provede operaci pop z~$X$ do $Y$, píšeme $X$  ${}_p{\Rightarrow}$  $Y$ $[mqA \rightarrow pv]$, zjednodušeně $X$  ${}_p{\Rightarrow}$  $Y$, pokud $X = (q, au, az)$, $Y = (q, u, z)$, kde $q \in Q$, $a \in \Sigma$, $u \in \Sigma^*$, $z \in \Gamma^*$.  
$M$ expanduje svůj zásobník z~$X$ do $Y$, píšeme $X$  ${}_e{\Rightarrow}$  $Y$ $[mqA \rightarrow pv]$, zjednodušeně $X$  ${}_e{\Rightarrow}$  $Y$, pokud $X = (q, w, uAz)$, $Y = (p, w, uvz)$, $mqA \rightarrow pv \in R$ a platí $\mathrm{occur}(u,\Gamma - \Sigma) = m - 1 $, kde $p$, $q \in Q$, $w \in \Sigma^*$, $A \in \Gamma$, $u$, $v$, $z \in \Gamma^*$. 
$M$ provede přechod z~$X$ do $Y$, píšeme $X$  ${\Rightarrow}$  $Y$ $[mqA \rightarrow pv]$, zjednodušeně $X$  ${\Rightarrow}$  $Y$,, pokud provede expanzi, nebo operaci pop.

%% sekvence přechodů
Nechť $X$ je konfigurace. $M$ provede nula přechodů z~$X$ do $X$, píšeme $X \Rightarrow^0 X [\epsilon]$, zjednodušeně $X \Rightarrow^0 X$. Nechť $X_0, X_1, X_2,\dots,X_n $ je sekvence přechodů konfigurací pro $n \ge 1$  a $X_{i-1} \Rightarrow X_i [r_i]$, kde $r_i \in R$, $i \in \{1, 2, 3,\dots, k\}$, tedy platí: $X_0 \Rightarrow X_1 [r_1] \Rightarrow X_2 [r_2] \dots \Rightarrow X_n [r_n]$. Pak $M$ provede $n$ přechodů z~$X_0$ do $X_n$. Píšeme $X_{0} \Rightarrow^n X_n [r_1 \dots r_n]$, zjednodušeně $X_{0} \Rightarrow^n X_n$. Pokud $X_{0} \Rightarrow^n X_n [r_1 \dots r_n]$ pro nějaké $n \ge 1$, pak $X_{0} \Rightarrow^+ X_n [r_1 \dots r_n]$. Pokud $X_{0} \Rightarrow^n X_n [r_1 \dots r_n]$ pro nějaké $n \ge 0$, pak $X_{0} \Rightarrow^* X_n [r_1 \dots r_n]$. Totéž platí pro operace pop a expanze.

% Hloubka a jazyk
Říkáme, že pravidlo $mqA \rightarrow pv \in R$ je hloubky $m$. Pokud existuje nejmenší přirozené číslo $n$ takové, že každé pravidlo v~$M$ je hloubky menší nebo rovno $n$, říkáme, že $M$ je hloubky $n$. Nechť M je hloubky n, pak jazyk přijímaný automatem ${}_nM$ je $L({}_nM) = \{ w \in \Sigma^* \mid (s,w,S) \Rightarrow^* (f, \epsilon, \epsilon)$, kde $f \in F \}$.


\end{Def}

% DEFINICE: FINITELY EXPANDABLE DEEP PDA

\begin{Def} Podle \cite{Meduna:FinitelyDeepPDA} je \emph{hluboký zásobníkový automat konečného indexu} uspořádaná osmice $M = (Q,\Sigma,\Gamma, R, s, S, F, n)$, jehož definice vychází z~hlubokého zásobníkového automatu. Symbol $n \in \{1,2,3,\dots\}$ označuje maximální počet nevstupních symbolů, které mohou být uložené na zásobníku. Expanze $X$  ${}_e{\Rightarrow}$  $Y$ může proběhnout jen v~případě, že v~konfiguraci $Y$ bude na zásobníku $n$ a méně nevstupních symbolů.  O~hloubce zásobníku tohoto typu automatu se předpokládá, že je rozšiřitelná tak, aby zásobník mohl přijmout až $n$ nevstupních symbolů.


%% Definovat krok, derivaci a jazyk

\end{Def}


%=========================================================================
\section{Řízené gramatiky}

% DEFINICE: BEZKONTEXTOVE GRAMATIKY
\begin{Def}\label{def_bezkontext_gram}

\emph{Bezkontextová gramatika} \cite{Krivka:RewritingSystems} je čtveřice $G = (V,T,P,S)$, kde $V = T \cup N$ je úplná abeceda, $T$ je abeceda terminálů, $N$ je abeceda neterminálů, $S \in N$ je počáteční symbol. $P$ je konečná množina pravidel tvaru $A \rightarrow v$, kde $A \in N$, $v \in V^*$.

Nechť $A \rightarrow v \in P$, $A \in N$, $v$, $x$, $y \in V^*$, pak bezkontextová gramatika $G$ provede derivační krok z~$xAy$ do $xvy$, píšeme $xAy \Rightarrow xvy [A \rightarrow v]$, zjednodušeně $xAy \Rightarrow xvy$. 
Nechť $r_1, r_2, \dots r_m \in P$ pro $m \ge 0$, pak $G$ může provést sekvenci kroků dle těchto pravidel, zápisem $x {\Rightarrow}^m y [r_1 r_2 \dots r_m]$. Píšeme ${\Rightarrow}^+$ pro libovolné $m > 0$ a ${\Rightarrow}^*$ pro $m \ge 0$. 

Gramatika $G$ generuje jazyk $L(G)$, pro který platí, že $L(G) = \{w \in T^* | S {\Rightarrow}^* w\}$. Jazyk $L$ je bezkontextový, právě když $L = L(G)$.

\end{Def}

% DEFINICE: PROGRAMOVA GRAMATIKA
\begin{Def}
\emph{Programová gramatika} \cite{Krivka:RewritingSystems} je čtveřice $G = (V,T,P,S)$, která vychází definice bezkontextové gramatiky. $P$ je konečná množina pravidel tvaru $r \colon A \rightarrow v, g(r)$, kde $r$ je označení pravidla, $A \rightarrow v$ je pravidlo bezkontextové gramatiky a $g(r)$ je množina značení těch pravidel, která mohou být provedena v~dalším derivačním kroku po aplikaci pravidla $r$.
\end{Def}

\begin{Def}
\emph{Programová gramatika konečného indexu $n$} \cite{Krivka:RewritingSystems} je programová gramatika $G = (V,T,P,S)$, pro jejíž každou větnou formu $w \in L(G)$ existuje taková posloupnost derivačních kroků, která v~žádném kroku neobsahuje více než $n$ neterminálů.
\end{Def}

% DEFINICE: STAVOVA GRAMATIKA
\begin{Def}
\emph{Stavová gramatika} je dle \cite{Kasai} šestice $G=(V,W,T,S,s,P)$ vycházející z~definice bezkontextové gramatiky. $V = T \cup N$ je úplná abeceda, $W$ je konečná množina stavů, $T$ je abeceda terminálů, $N$ je abeceda neterminálů, $S \in N$ je počáteční symbol, $s \in W$ je počáteční stav a $P$ je konečná relace $(W \times N) \times (W \times V^+)$; pravidla píšeme $(q,A) \rightarrow (p,v)$.

Nechť $(q,A) \rightarrow (p,v) \in P$, $p$, $q \in W$, $A \in N$, $v$, $x$, $y \in V^*$, pak stavová gramatika $G$ provede derivační krok z~$xAy$ do $xvy$, píšeme $(q, xAy) \Rightarrow (p, xvy) [(q,A) \rightarrow (p,v)]$, zjednodušeně $xAy \Rightarrow xvy$, právě tehdy když $\{Z \mid (q,Z) \rightarrow (p',v') \in P$, $Z \in \mathrm{alph}(x) \cap N$, $p' \in W$, $v' \in V^* \} = \emptyset$. 

Gramatika $G$ generuje jazyk $L(G) = \{w \in T^* | (s, S) {\Rightarrow}^* (p, w), p,q \in W \}$.


\end{Def}

\begin{Def}
\emph{Stavová gramatika konečného indexu $n$} je stavová gramatika $G=(V,W,T,S,s,P)$, pro kterou platí, že derivační krok $(q, xAy) \Rightarrow (p, xvy)$ za pomoci pravidla $(q,A) \rightarrow (p,v) \in P$, kde $p$, $q \in W$, $A \in N$, $v$, $x$, $y \in V^*$, lze provést právě tehdy, když je počet neterminálů v~řetězci $xA$ menší nebo roven $n$. Píšeme $(q, xAy) {}_n\Rightarrow (p, xvy)$. 

Gramatika $G$ generuje jazyk $L(G) = \{w \in T^* | (s, S) {}_n{\Rightarrow}^* (p, w), p,q \in W \}$.

\end{Def}

\begin{Def}
\emph{Stavová gramatika s~$\epsilon$-pravidly} je podle \cite{Meduna:StateGrammars} stavová gramatika $G=(V,W,T,S,s,P)$ rozšířená o~vymazávací pravidla typu $(q,A) \rightarrow (p,\epsilon)$, kde $p$, $q \in W$, $A \in N$.
\end{Def}


%=========================================================================
\section{Hierarchie mezi kontextovými a bezkontextovými jazyky}

% definovat rodiny jazyků příslušných modelů a zařadit je do kontextu, obrázek - viz. křivka?


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Hluboký zásobníkový automat s~jedním nevstupním symbolem}
%TODO Úvod k omezení počtu nevstupních symbolů, zavedení nového typu automatu


%=========================================================================
\section{Omezení počtu nevstupních symbolů}\label{section_deep_pda_nonterm}
% TODO Srovnání síly nového automatu s druhým typem - algoritmus

Omezím-li počet nevstupních symbolů zásobníkového automatu $M$ na jeden, mohu zavést nový automat $M_\#$ a zkoumat jeho sílu. Převod automatu $M$ na  $M_\#$ popisuji algoritmem \ref{alg_PDA}. Pro účely simulace zavádím nové stavy, kde uchovávám informace o~stavu automatu a nahrazeném obsahu zásobníku. To je možné díky konečnému počtu nevstupních symbolů na zásobníku, neboť jinak by takové řešení vedlo k~nekonečnému počtu stavů. Každé pravidlo pak lze snadno převést na jeho ekvivalent nahrazením nevstupních symbolů symbolem $\#$ a jejich uložením do stavu.

\begin{Alg} \label{alg_PDA}
Převod hlubokého zásobníkového automatu konečného indexu na ekvivalentní s~jedním nevstupním symbolem.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F, n)$ 
   \item Výstup: $M_\# = (Q_\#,{\Sigma}_\#,{\Gamma}_\#, R_\#, s_\#,  S_\#, F_\#, n)$ \medskip
  
  \item ${\Sigma}_\# := \Sigma$
  \item ${\Gamma}_\# :=\{\#\} \cup \Sigma$
  \item $s_\# := <s,\#>$
  \item $S_\# := \# $ \medskip

  \item Pro každé $mqA \rightarrow pv \in R$, kde $v = b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j$, $j \in \{0,1,2,3,\dots,n\}$, $b_0,b_i \in {\Sigma}^*$ a $B_i \in (\Gamma - \Sigma)$ pro všechna $i \in \{1,2,\dots,j\}$ : \smallskip

  \subitem A~pro každé $(u,z) \in (\Gamma - \Sigma)^* \times (\Gamma - \Sigma)^*$, kde $|u|=m-1$, $|z|\le n-m$ : \smallskip

  \subsubitem přidej do $Q_\#$ stavy $<q, u A z>$, $<p, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R_\#$ pravidlo $m <q, u A z> \# \rightarrow <p, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j $,
  \subsubitem pokud $q \in F$, přidej do $F_\#$ stav $<q, u A z>$,
  \subsubitem pokud $p \in F$, přidej do $F_\#$ stav $<p, u B_1 B_2 \dots B_{j-1} B_{j} z>$.

\end{list}
\end{Alg}

Je zřejmé, že každý hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem splňuje definici pro obecný hluboký zásobníkový automat konečného indexu. Tudíž spolu s~algoritmem \ref{alg_PDA} jsem ukázala ekvivalenci těchto automatů.

%=========================================================================
\section{Ekvivalence s~programovými gramatikami konečného indexu}
% TODO Srovnání síly z programovými gramatikami - algoritmus

%TODO příklad převedení

V~\cite{Meduna:FinitelyDeepPDA} je dokázáno, že hluboké zásobníkové automaty konečného indexu jsou ekvivalentní s~maticovými gramatikami konečného indexu, tudíž třídy jazyků, které zásobníkový automat přijímá, tvoří nekonečnou hierarchii. Vzhledem k~výsledkům v~kapitole \ref{section_deep_pda_nonterm} lze očekávat, že tato vlastnost automatu zůstane i při omezení počtu nevstupních symbolů. Konstrukci důkazu tohoto tvrzení ukážu na ekvivalenci s~programovými gramatikami, přičemž je očividné, že maticové a programové gramatiky konečného indexu generují stejný jazyk (viz \cite{Dassow:RegulatedRewriting}).

Pro hluboký zásobníkový automat dle \cite{Meduna:FinitelyDeepPDA} platí, že jestliže přijme nějaké slovo $w$, pak existuje taková komputace tohoto slova, která provádí pouze pop operace po první pop operaci. Toto tvrzení využiji v~následujícím důkazu, neboť zásobníkový automat, na kterém probíhají jen expanze funguje jako gramatika. Stačí proto ukázat, že automat je schopen na svém zásobníku simulovat všechny derivace gramatiky a opačně.

Pomocí algoritmu \ref{alg_PG} popisuji způsob, jakým lze převést programovou gramatiku konečného indexu na hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem. Stav automatu se v~tomto případě skládá ze dvou položek: označení pravidla, které se bude simulovat v~dalším kroku, a řetězce neterminálů, které jsou na zásobníku nahrazené symbolem $\#$. Automat přejde do koncového stavu, pokud jeho zásobník neobsahuje žádné neterminály.
 %%%

\begin{Alg} \label{alg_PG}
Převod programové gramatiky konečného indexu na ekvivalentní hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
  \item Vstup: $G = (T \cup N ,T,P,S)$ konečného indexu $n$
  \item Výstup: $M = (Q,\Sigma,\Gamma, R, s, S , F, n)$ \medskip
  
  \item ${\Sigma} := T$
  \item ${\Gamma} := T \cup \{\#\}$
  \item $s_\# := <\sigma>$
  \item $S_\# := \# $ \medskip

  \item Pro každé $p: S \rightarrow v, g(p) \in P$: 
  \subitem přidej do $R$ pravidlo $<\sigma>_1 \# \rightarrow <p, S> \#$ a do $Q$ stav $<p, S>$. \medskip

  \item Pro každé $q \in (Q \cup \{\varepsilon\})$: 
  \subitem přidej do $F$ stav $<q, \varepsilon>$. \medskip

  \item Pro každé $p: A \rightarrow v, g(p) \in P$,  kde $v=b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j$, $j \in \{0,1,2,3,\dots,n\}$, $b_0,b_i \in T^*$ a $B_i \in N$ pro všechna $i \in \{1,2,\dots,j\}$ : \medskip
  \subitem Pro každé $(k,u,z) \in \{1,2,3,\dots,n-j+1\} \times N^* \times N^*$, kde $|u| = k-1$, $|z|  \le n-k$ : \medskip
  \subsubitem Pokud $g(p) = \emptyset$ :
  \subsubitem přidej do $Q$ stavy $<p,uAz>$, $<\varepsilon, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R$ pravidlo $<p,uAz>_k \# \rightarrow <\varepsilon, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j$.\medskip
  \subsubitem Jinak pro každé $q \in g(p)$:
  \subsubitem přidej do $Q$ stavy $<p,uAz>$, $<q, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R$ pravidlo $<p,uAz>_k \# \rightarrow <q, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j$.

\end{list}
\end{Alg}

Konstrukce důkazu o~převodu hlubokého zásobníkového automatu konečného indexu s~jedním nevstupním symbolem na programovou gramatiku konečného indexu je dohledatelná ve článku \cite{Krivka:RewritingSystems}, který srovnává programové gramatiky s~\#-Rewriting Systems. Programová gramatika simuluje každý krok zásobníkového automatu sekvencí několika derivací. Neterminály obsahují informace o~stavu zásobníku, aktuální pozici výskytu symbolu \# a celkovém počtu všech \# v~aktuální konfiguraci. Vlastní simulace probíhá následovně:

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
\item 1. Aktualizace pozice a celkového počtu nevstupních symbolů u~všech neterminálů.
\item 2. Expanze neterminálu na příslušné pozici.
\item 3. Odstranění pomocných stavů.
\end{list}

Tím jsem ukázala, že výše zavedený typ zásobníkového automatu je ekvivalentní s~programovými gramatikami. Z~toho vyplývá, že rodina jazyků přijímaná tímto zásobníkovým automatem tvoří nekonečnou hierarchii vycházející z~programových gramatik.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Hluboký zásobníkový automat v~normální formě}

V~této kapitole zavádím normální formu hlubokého zásobníkového automatu a ukazuji způsob, jakým lze automat na tuto formu převést. Vycházím z~myšlenky automatu s~jedním nevstupním symbolem, kterému jsem se věnovala doposud. Hluboký zásobníkový automat je ale zobecněním konečného a nemá omezení pro počet nevstupních symbolů na zásobníku. Z~toho důvodu není možné na něj aplikovat algoritmus \ref{alg_PDA}, neboť by to vedlo k~nekonečnému počtu stavů a pravidel. Je ale možné pracovat podobným způsobem s~tzv. prefixem zásobníku, kdy nejvrchnějších $n$ nevstupních symbolů nahrazuji symbolem $\#$. Celkový počet nevstupních symbolů jsem tak nijak nezredukovala, ale docílila jsem zjednodušeného zápisu pravidel.

% definice
% algoritmus
% ekvivalence

%=========================================================================
\section{Definice normální formy}

\begin{Def}\label{def_NF}
Nechť $M = (Q,\Sigma,\Gamma, R, s, S , F)$ je hluboký zásobníkový automat
a $n$ je maximální hloubka expanze v~$M$.
Pak $M$ je v~normální formě, pokud každé pravidlo z~$R$ je v~jednom ze tvarů:

\begin{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

\item $mqA \rightarrow p\#$, kde $A \in (\Gamma - \Sigma)$, $1 \le m \le n$, $p$, $q \in Q$,
\item $mq\# \rightarrow p\#$, kde $1 \le m \le n$, $p$, $q \in Q$,
\item $mq\# \rightarrow pa$, kde $a \in {\Sigma}^+$, $1 \le m \le n$, $p$, $q \in Q$,
\item $mq\# \rightarrow p\#A$, kde $A \in (\Gamma - \Sigma)$, $1 \le m \le n$, $p$, $q \in Q$.

\end{enumerate}

\end{Def}
\medskip
Hluboký zásobníkový automat v~normální formě dle definice \ref{def_NF} pracuje s~prefixem $n$ nevstupních symbolů. Přepis symbolů v~prefixu na symbol $\#$ umožňuje pravidlo typu (i), změnu stavu pravidlo (ii), přepis na symbol vstupní abecedy pravidlo typu (iii) a expandovat lze pravidlem typu (iv). Nechť pravidlo typu (iv) je možné aplikovat jen na nejspodnější symbol $\#$, pak na zásobníku je v~každém kroku derivace řetězec z~množiny $ ( \Sigma^* \{ \# \} )^k  \Gamma^*$, kde $0 \le k \le n$. 

\section{Převod na normální formu}

Při sestavování algoritmu pro převod hlubokého zásobníkového automatu do normální formy jsem musela řešit zejména omezené možnosti expanze. Původní stav automatu a nevstupní symboly z~prefixu opět uchovávám ve stavech. Pokud bych ale připustila expanzi na libovolný počet nevstupních symbolů, ztratila bych ze stavu informaci o~nahrazených nevstupních symbolech, které by se ocitly za prefixem, nebo bych zvětšovala velikost prefixu a počet pomocných stavů by tak narostl do nekonečna. Tento problém jsem vyřešila tzv. postupnou expanzí. Pravá strana pravidla je reprezentovaná jedním nevstupním symbolem. Ten je možné expandovat na právě dva nevstupní symboly: první symbol v~řetězci a zbytek řetězce. Jednoduchou rekurzí tohoto postupu lze dosáhnout úplné expanze.

Expanze na dva nevstupní symboly je již udržitelná, ale stále se může stát, že poslední symbol $\#$ bude odsunut o~jednu pozici za prefix. Nabízí se povolit pravidlo pro přepis tohoto symbolu na původní nevstupní symbol, ale tím bych zvýšila hloubku automatu. Místo toho spojuji krok expanze a krok přepisu posledního $\#$ symbolu na původní symbol do jednoho pravidla typu (iv). Expanze tak nemá vliv na $\#$ symboly v~prefixu.

V~algoritmu \ref{alg_NF} popisuji konstrukci hlubokého zásobníkového automatu v~normální formě. S~ohledem na postupnou expanzi zavádím nové nevstupní symboly, jejichž součástí je rovněž původní pravidlo pro expanzi. Nelze určit dopředu, kdy se jednotlivé kroky expanze provedou, proto je nutné je umožnit provést ve všech stavech automatu a na všech pozicích v~prefixu. 

\begin{Alg}\label{alg_NF}
Převod hlubokého zásobníkového automatu do normální formy.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F)$ 
   \item Výstup: $M_{NF} = (Q_{NF}, \Sigma_{NF}, {\Gamma}_{NF}, R_{NF}, s_{NF},  S_{NF}, F_{NF})$ \medskip
  
  \item ${\Sigma}_{NF} := \Sigma$
  \item ${\Gamma}_{NF} :=\{\#\} \cup \Sigma$
  \item $s_{NF} := <s,S>$
  \item $S_{NF} := \#$ \medskip

  \item $k := \mathrm{max}(\{m \mid mqA \rightarrow pv \in R\}) $ \medskip

  \item Pro každé $(q,u,A) \in Q \times (\Gamma - \Sigma)^* \times (\Gamma - \Sigma)$, kde $|u| < k$: \medskip

  \subitem přidej do $R_{NF}$ pravidlo typu (i) $|uA| <q,u> A \rightarrow <q,uA> \#$. \medskip

  \item Pro každé $r : mqA \rightarrow p X_1 X_2 X_3 \dots X_j \in R$, kde $1 \le i \le j$, $X_i \in \Gamma$, a 
         pro každou dvojici $(u,v) \in (\Gamma - \Sigma)^* \times (\Gamma - \Sigma)^*$, kde $|uv| < k$ : \medskip

  \subitem Pokud $|u| = m - 1$, $|v| \le k-m$, přidej do $R_{NF}$ pravidlo typu (ii) :
  \subitem $m <q,uAv> \# \rightarrow <p,u (r : X_1 X_2 X_3 \dots X_j) v>\#$ . \medskip

  \subitem Pro každé $(X_i,q') \in \{X_1, X_2, X_3, \dots, X_j\} \times Q$: \medskip

  \subsubitem Pokud $X_i \in (\Gamma - \Sigma)$, přidej do $R_{NF}$ pravidlo typu (ii) :
  \subsubitem $|u|+1 <q',u (r : X_i) v> \# \rightarrow <q',u X_i v> \# $. \medskip

  \subsubitem Pokud $X_i \in \Sigma$, přidej do $R_{NF}$ pravidlo typu (iii) :
  \subsubitem $|u|+1 <q',u (r : X_i) v> \# \rightarrow <q',uv> X_i $.\medskip

  \subsubitem Pokud $i < j$, přidej do $R_{NF}$ pravidlo typu (iv) :

  \subsubitem $|uv|+1 <q',u(r : X_i X_{i+1} \dots X_j)v> \# \rightarrow <q',u(r : X_i) (r: X_{i+1} \dots X_j)v'>\# V' $
  \subsubitem pro $v \ne \varepsilon$, kde $v = V_1 V_2 V_3 \dots V_{l-1} V_l$, $v' = V_1 V_2 V_3 \dots V_{l-1}$ a $V'=V_l$, jinak
  \subsubitem $|u|+1 <q',u(r : X_i X_{i+1} \dots X_j)> \# \rightarrow <q',u(r : X_i)>\# (r: X_{i+1} \dots X_j)$.\bigskip

  \item $Q_{NF} := \{p,q \mid mqA \rightarrow pv \in R_{NF}\} $
  \item $F_{NF} := \{<q, \varepsilon> \mid  q \in F \}$


\end{list}
\end{Alg}

%=========================================================================
%\section{Ekvivalence s~...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Zobecněný hluboký zásobníkový automat a jeho redukce}

% Definice

\begin{Def}
Zobecněný hluboký zásobníkový automat je uspořádaná sedmice $M = (Q,\Sigma,\Gamma, R, s, S, F)$, 
kde $Q$ je konečná množina stavů, $\Sigma$ vstupní abeceda, $\Gamma$ zásobníková abeceda, přičemž $\Sigma \subset \Gamma$,
$s \in Q$ je počáteční stav, $S \in \Gamma$ počáteční symbol na zásobníku a $F \subset Q$ je množina
koncových stavů. $R$ je konečná množina pravidel typu $(q, A, p, v) \in Q \times (\Gamma - \Sigma) \times Q \times {\Gamma}^+$, které píšeme ve tvaru $qA \rightarrow pv$. 
\end{Def}

\begin{Def}
Nechť $M = (Q,\Sigma,\Gamma, R, s, S, F)$ je zobecněný hluboký zásobníkový automat, $(w,q,uAz)$ a $(w,p,uvz)$ jeho dvě konfigurace a $qA \rightarrow pv \in R$ pravidlo. Pak lze provést přechod z~$(w,q,uAz)$ do $(w,p,uvz)$, píšeme $(w,q,uAz) {\Rightarrow} (w,p,uvz)$, právě tehdy když platí: $\{X \mid qX \rightarrow p'v' \in R$, kde $X \in \mathrm{alph}(u) \cap (\Gamma - \Sigma)$, $p' \in Q$, $v' \in {\Gamma}^+ \} = \emptyset$.
\end{Def}

%=========================================================================
 \section{Ekvivalence se stavovými gramatikami} \label{sec_ekv_state_grammars}

% ekvivalence se stavovými gramatikami, povolení epsilon pravidel, co s toho vyplývá
% algoritmus a důkaz

Zřejmé. Stavové gramatiky jsou left-most, hluboké automaty top-most, pravidla jsou ve stejném tvaru. Doplnit.

%=========================================================================
\section{Omezení počtu nevstupních symbolů}

% odkaz na článek on state grammars, co s toho vyplývá
% algoritmus

Ve článku \ref{DOPLNIT} je dokázáno, že každá stavová gramatika s~$\varepsilon$-pravidly má svůj ekvivalentní protějšek se třemi nevstupními symboly. S~ohledem na výsledek kapitoly \ref{sec_ekv_state_grammars} je na místě prozkoumat, zda lze takové redukce dosáhnout i u~zobecněných hlubokých automatů.

V~algoritmu \ref{alg_gen_deep_pda_nonterm} demonstruji redukci nevstupních symbolů na symboly 0, 1 a \#. Hlavní myšlenka spočívá v~reprezentaci všech zásobníkových symbolů pomocí nul a jedniček. Symbol \# označuje fyzické dno zásobníku a umožňuje přesouvat symboly z~vrcholu na jeho konec. Zároveň k~symbolu \# zavádím binární ekvivalent, který označuje logické dno zásobníku. 

Princip simulace spočívá v~rozpoznání symbolu na vrcholu zásobníku pomocí pravidel z~množiny $R_{find}$ a jeho přesunu na dno zásobníku, případně expanzi pravidlem z~$R_{exp}$. Pokud dojde k~expanzi, aplikují se pravidla s~množiny $R_{move}$, které přesunou zbývající symboly na dno. Pokud pro žádný nevstupní symbol v~zásobníku expanze neproběhne, automat nahradí binární reprezentace vstupních symbolů samotnými symboly pomocí pravidel z~množiny $R_{end}$, smaže pomocné nevstupní symboly a přejde do koncového stavu.

\begin{Alg}\label{alg_gen_deep_pda_nonterm}
Převod zobecněného hlubokého zásobníkového automatu s~$\varepsilon$-pravidly na ekvivalentní se třemi nevstupními symboly.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F)$ 
   \item Výstup: $M_{R} = (Q_{R}, \Sigma_{R}, {\Gamma}_{R}, R_{R}, s_{R},  S_{R}, F_{R})$ \medskip
  
   \item ${\Sigma}_{R} := \Sigma$
   \item ${\Gamma}_{R} := \Sigma \cup \{0,1,\#\}$
   \item $R_{R} := R_{find} \cup R_{next} \cup R_{exp} \cup R_{move} \cup R_{end}$
   \item $s_{R} := <start> $
   \item $S_{R} := \# $
   \item $F_{R} := \{<end>\} $ \medskip

\medskip

  \item Nechť $\Gamma = \{X_1, X_2, X_3, \dots, X_n\}$ pro $n \ge 1$ je množina všech zásobníkových symbolů v~$M$ a $X_0$ značí symbol $\#$. Pak definujme funkci $\varphi : \Gamma \cup \{\#\} \rightarrow \{0,1\}^*$ tak, že $\varphi (X_i)=0^i 1$ pro $i = 0,1,2,\dots,n$. \medskip

  \item Přidej do $Q_R$ pro každé $q \in Q$, $0 \le i \le n$ stavy:
  \item $<start>$, $<q, 0^i>$, $<q, 0^i 1>$, $<q, 0^i>'$, $<q, 0^i 1>'$, $<q, 0^i>''$, $<q, 0^i 1>''$, $<end>$.\medskip

  \item Pro každé $qA \rightarrow p B_0 B_1 \dots B_{j-1} B_{j} \in R$, kde $p, q \in Q$, $j \ge 0$, $B_0,B_1,\dots,B_j \in \Gamma$ a $A \in (\Gamma - \Sigma)$, 
          přidej $<q, \varphi (A)>$ do množiny $Q_{exp}$  a do $R_{exp}$ pravidla:

\begin{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<start> \# \rightarrow <s, \varepsilon> \varphi(S)\varphi(\#)\#$,
  \item $<q, \varphi (A)> \# \rightarrow <p, \varepsilon>' \varphi(B_0)\varphi(B_1)\varphi(B_2) \dots \varphi(B_{j-1}) \varphi(B_{j}) \#$.

\suspend{enumerate}

  \item Pro každé $q \in Q$, $0 \le i \le n$ přidej do $R_{find}$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<q, 0^i> 0 \rightarrow <q, 0^{i+1}> \varepsilon $, $<q, 0^i> 1 \rightarrow <q, 0^i 1> \varepsilon $,
  \item $<q, 0^i>' 0 \rightarrow <q, 0^{i+1}>' \varepsilon $, $<q, 0^i>' 1 \rightarrow <q, 0^i 1>' \varepsilon $
  \item $<q, 0^i>'' 0 \rightarrow <q, 0^{i+1}>'' \varepsilon $, $<q, 0^i>'' 1 \rightarrow <q, 0^i 1>'' \varepsilon $.

\suspend{enumerate}


  \item Přidej do $R_{next}$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<q, \varphi(X)> \# \rightarrow <q, \varepsilon> \varphi(X) \# $, kde $X \in \Gamma$, $q \in Q$, $<q, \varphi(X)> \notin Q_{exp}$,
  \item $<q, \varphi(\#) > \# \rightarrow <q, \varepsilon>'' \varphi(\#) \# $, kde $q \in Q$.

\suspend{enumerate}

  \item Přidej do $R_{move}$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<q, \varphi(X)>' \# \rightarrow <q, \varepsilon>' \varphi(X) \# $, kde $X \in \Gamma$, $q \in Q$,
  \item $<q, \varphi(\#) >' \# \rightarrow <q, \varepsilon> \varphi(\#) \# $, kde $q \in Q$.

\suspend{enumerate}

  \item Přidej do $R_{end}$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

  \item $<q, \varphi(X) >'' \# \rightarrow <q, \varepsilon>'' X \# $, kde $X \in \Sigma$, $q \in Q$,
  \item $<q, \varphi(X) >'' \# \rightarrow <q, \varepsilon>'' \varphi(X) \# $, kde $X \in (\Gamma - \Sigma)$, $q \in Q$,
  \item $<q, \varphi(\#) >'' \# \rightarrow <end> \epsilon $, kde $q \in Q$.

\end{enumerate}

\end{list}
\end{Alg}



%=========================================================================
\section{Omezení počtu stavů}

% odkaz na článek on state grammars
% algoritmus

Pro každou stavovou gramatiku dle \ref{DOPLNIT} platí, že existuje ekvivalentní stavová gramatika taková, že má právě tři stavy. V~algoritmu \ref{alg_gen_deep_pda_state} ukazuji, že totéž platí pro zobecněné hluboké zásobníkové automaty.

Pokud automat může být jen v~jednom ze tří stavů, je zřejmé, že informace o~stavu simulovaného automatu musí být součástí každého nevstupního symbolu. Musela jsem tedy najít způsob, jak aktualizovat hodnotu tohoto stavu ve všech nevstupních symbolech na novou. Zvolila jsem princip \uv{kruhového bufferu}. Pokud nad stavy definuji uspořádání, pak lze přepsat první stav na druhý, druhý na třetí,\dots, předposlední na poslední a poslední na první. Počet těchto přepisů určuje symbol čítače, jehož hodnota se po každé změně stavu ve všech nevstupních symbolech sníží o~1. Zobecněný hluboký zásobníkový automat expanduje nejvrchnější nevstupní symbol, který lze. Proto ke každému nevstupnímu symbolu s~upravených stavem přidávám apostrof. Pro takový symbol v~daném stavu neexistuje pravidlo a automat se přesune na další symbol až po konec zásobníku. Po snížení hodnoty čítače se ze symbolů na zásobníku odstraní apostrofy a v~případě, že je čítač vynulovaný, se provede expanze. Pokud expanze způsobí změnu stavu, vygeneruje se nový čítač a celý postup se opakuje.

Funkčnost tohoto principu je závislá na rozdělení pravidel mezi tři stavy tak, aby automat v~žádném případě nemohl vykonat nežádaný krok. V~algoritmu \ref{alg_gen_deep_pda_state} řeším tento problém následovně: Množina $R_{\alpha}$ obsahuje pravidla pro expanzi, změnu hodnoty čítače a nastavení příznaku pro expanzi. Pravidla z~$R_{\beta}$ mění stav v~nevstupních symbolech a symboly značí apostrofem. Množina pravidel $R_{\gamma}$ odstraňuje apostrofy z~nevstupních symbolů a podle příznaku na konci zásobníku automat přejde do stavu pro expanzi, nebo pro aktualizaci stavů.

\begin{Alg}\label{alg_gen_deep_pda_state}
Převod zobecněného hlubokého zásobníkového automatu s~$\varepsilon$-pravidly na ekvivalentní s~redukcí na tři stavy.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F)$ 
   \item Výstup: $M_{R} = (Q_{R}, \Sigma_{R}, {\Gamma}_{R}, R_{R}, s_{R},  S_{R}, F_{R})$ \medskip

   \item ${\Sigma}_{R} := \Sigma$
   \item ${\Gamma}_{R} := \Sigma \cup {\Gamma}_{R}'$
   \item $Q_{R} := \{s_\alpha, s_\beta, s_\gamma \}$
   \item $R_{R} := R_{\alpha} \cup R_{\beta} \cup R_{\gamma}$
   \item $s_{R} := s_{\alpha} $
   \item $S_{R} := <start> $
   \item $F_{R} := \{s_{\alpha}\} $ \medskip

   \item Nechť $Q = \{s_0, s_1, s_2, \dots,s_{|Q|}\}$, kde $s_0 = s$ je počáteční stav v~$M$. Nechť $s_{|Q|+1} = s_0$.\medskip

   \item Pro každé $q \in Q$, $X \in (\Gamma - \Sigma)$, $j \in \{1,2,3,\dots,|Q|\}$ přidej do ${\Gamma}_{R}'$ symboly :
   \item $<start>, <j>, <q, X>, <q, X>', <q, \#>, <q, \#>_{set}, <q, \#>_{exp}$.\medskip

   \item Pro každé $qA \rightarrow p b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j \in R$, kde $p, q \in Q$, $j \ge 0$, $b_0,b_1,\dots,b_j \in {\Sigma}^*$ a $A, B_1,B_2,\dots,B_j \in (\Gamma - \Sigma)$. 
         Nechť $k$ je absolutní hodnota rozdílu indexů stavů $p$ a $q$. 
         Pak přidej do $R_\alpha$ pravidla:

\begin{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

   \item $s_\alpha <start> \rightarrow s_\alpha <s_0, S> <s_0, \#>$,
   \item  $s_\alpha <q, A> \rightarrow s_\alpha b_0 <q, B_1> b_1 <q, B_2> b_2 \dots b_{j-1} <q, B_j> b_j$ pokud $p = q$,
   \item  $s_\alpha <q, A> \rightarrow s_\beta <k> b_0 <q, B_1> b_1 <q, B_2> b_2 \dots b_{j-1} <q, B_j> b_j$ pro $p \ne q$. 

\suspend{enumerate}

   \item Přidej do $R_\beta$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

   \item $s_\beta <s_i, X> \rightarrow s_\beta <s_{i+1}, X>'$ pro každé $s_i \in Q$ a každé $X \in (\Gamma - \Sigma)$,
   \item $s_\beta <s_i, \#> \rightarrow s_\alpha <s_{i+1}, \#>_{set}$ pro každé $s_i \in Q$.

\suspend{enumerate}

   \item Přidej do $R_\alpha$ pravidla:

\resume{enumerate}{\setlength\leftmargin{1em}}
\renewcommand{\labelenumi}{(\roman{enumi})}

   \item $s_\alpha <j> \rightarrow s_\gamma <j - 1 > $ pro každé $j \in \{2,3,\dots,|Q|\}$,
   \item $s_\alpha <1> \rightarrow s_\alpha \varepsilon $,
   \item $s_\alpha <s_i, \#>_{set} \rightarrow s_\gamma <s_{i}, \#>_{exp}$ pro každé $s_i \in Q$,
   \item $s_\alpha <q, \#> \rightarrow s_\alpha \varepsilon $ pro každé $q \in F$.

\suspend{enumerate}{\setlength\leftmargin{1em}}

   \item Přidej do množiny $R_\gamma$ pravidla:

\resume{enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}

   \item $s_\gamma <s_i, X>' \rightarrow s_\gamma <s_i, X> $ pro každé $s_i \in Q$ a každé $X \in (\Gamma - \Sigma)$,
   \item $s_\gamma <s_i, \#>_{set} \rightarrow s_\beta <s_i, \#>$ pro každé $s_i \in Q$,
   \item $s_\gamma <s_i, \#>_{exp} \rightarrow s_\alpha <s_{i}, \#>$ pro každé $s_i \in Q$.

\end{enumerate}

\end{list}
\end{Alg}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Aplikace \texttt{deeppda}}
\chapter{Aplikace}

\section{Návrh}

\section{Implementace}

\section{Uživatelská příručka}

\section{Ukázka vstupů a výstupů}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Závěr}
%TODO Dolnit až na konec



%=========================================================================
