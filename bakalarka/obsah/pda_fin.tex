%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Hluboký zásobníkový automat s~jedním nevstupním symbolem}
%TODO Úvod k omezení počtu nevstupních symbolů, zavedení nového typu automatu


%=========================================================================
\section{Omezení počtu nevstupních symbolů}\label{section_deep_pda_nonterm}
% TODO Srovnání síly nového automatu s druhým typem - algoritmus

Omezím-li počet nevstupních symbolů zásobníkového automatu $M$ na jeden, mohu zavést nový automat $M_\#$ a zkoumat jeho sílu. Převod automatu $M$ na  $M_\#$ popisuji algoritmem \ref{alg_PDA}. Pro účely simulace zavádím nové stavy, kde uchovávám informace o~stavu automatu a nahrazeném obsahu zásobníku. To je možné díky konečnému počtu nevstupních symbolů na zásobníku, neboť jinak by takové řešení vedlo k~nekonečnému počtu stavů. Každé pravidlo pak lze snadno převést na jeho ekvivalent nahrazením nevstupních symbolů symbolem $\#$ a jejich uložením do stavu.

\begin{Alg} \label{alg_PDA}
Převod hlubokého zásobníkového automatu konečného indexu na ekvivalentní s~jedním nevstupním symbolem.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
   \item Vstup: $M = (Q,\Sigma,\Gamma, R, s, S, F, n)$ 
   \item Výstup: $M_\# = (Q_\#,{\Sigma}_\#,{\Gamma}_\#, R_\#, s_\#,  S_\#, F_\#, n)$ \medskip
  
  \item ${\Sigma}_\# := \Sigma$
  \item ${\Gamma}_\# :=\{\#\} \cup \Sigma$
  \item $s_\# := <s,\#>$
  \item $S_\# := \# $ \medskip

  \item Pro každé $mqA \rightarrow pv \in R$, kde $v = b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j$, $j \in \{0,1,2,3,\dots,n\}$, $b_0,b_i \in {\Sigma}^*$ a $B_i \in (\Gamma - \Sigma)$ pro všechna $i \in \{1,2,\dots,j\}$ : \smallskip

  \subitem A~pro každé $(u,z) \in (\Gamma - \Sigma)^* \times (\Gamma - \Sigma)^*$, kde $|u|=m-1$, $|z|\le n-m$ : \smallskip

  \subsubitem přidej do $Q_\#$ stavy $<q, u A z>$, $<p, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R_\#$ pravidlo $m <q, u A z> \# \rightarrow <p, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j $,
  \subsubitem pokud $q \in F$, přidej do $F_\#$ stav $<q, u A z>$,
  \subsubitem pokud $p \in F$, přidej do $F_\#$ stav $<p, u B_1 B_2 \dots B_{j-1} B_{j} z>$.

\end{list}
\end{Alg}

Je zřejmé, že každý hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem splňuje definici pro obecný hluboký zásobníkový automat konečného indexu. Tudíž spolu s~algoritmem \ref{alg_PDA} jsem ukázala ekvivalenci těchto automatů.

%=========================================================================
\section{Ekvivalence s~programovými gramatikami konečného indexu}
% TODO Srovnání síly z programovými gramatikami - algoritmus

%TODO příklad převedení

V~\cite{Meduna:FinitelyDeepPDA} je dokázáno, že hluboké zásobníkové automaty konečného indexu jsou ekvivalentní s~maticovými gramatikami konečného indexu, tudíž třídy jazyků, které zásobníkový automat přijímá, tvoří nekonečnou hierarchii. Vzhledem k~výsledkům v~kapitole \ref{section_deep_pda_nonterm} lze očekávat, že tato vlastnost automatu zůstane i při omezení počtu nevstupních symbolů. Konstrukci důkazu tohoto tvrzení ukážu na ekvivalenci s~programovými gramatikami, přičemž je očividné, že maticové a programové gramatiky konečného indexu generují stejný jazyk (viz \cite{Dassow:RegulatedRewriting}).

Pro hluboký zásobníkový automat dle \cite{Meduna:FinitelyDeepPDA} platí, že jestliže přijme nějaké slovo $w$, pak existuje taková komputace tohoto slova, která provádí pouze pop operace po první pop operaci. Toto tvrzení využiji v~následujícím důkazu, neboť zásobníkový automat, na kterém probíhají jen expanze funguje jako gramatika. Stačí proto ukázat, že automat je schopen na svém zásobníku simulovat všechny derivace gramatiky a opačně.

Pomocí algoritmu \ref{alg_PG} popisuji způsob, jakým lze převést programovou gramatiku konečného indexu na hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem. Stav automatu se v~tomto případě skládá ze dvou položek: označení pravidla, které se bude simulovat v~dalším kroku, a řetězce neterminálů, které jsou na zásobníku nahrazené symbolem $\#$. Automat přejde do koncového stavu, pokud jeho zásobník neobsahuje žádné neterminály.
 %%%

\begin{Alg} \label{alg_PG}
Převod programové gramatiky konečného indexu na ekvivalentní hluboký zásobníkový automat konečného indexu s~jedním nevstupním symbolem.

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
  \item Vstup: $G = (T \cup N ,T,P,S)$ konečného indexu $n$
  \item Výstup: $M = (Q,\Sigma,\Gamma, R, s, S , F, n)$ \medskip
  
  \item ${\Sigma} := T$
  \item ${\Gamma} := T \cup \{\#\}$
  \item $s_\# := <\sigma>$
  \item $S_\# := \# $ \medskip

  \item Pro každé $p: S \rightarrow v, g(p) \in P$: 
  \subitem přidej do $R$ pravidlo $<\sigma>_1 \# \rightarrow <p, S> \#$ a do $Q$ stav $<p, S>$. \medskip

  \item Pro každé $q \in (Q \cup \{\varepsilon\})$: 
  \subitem přidej do $F$ stav $<q, \varepsilon>$. \medskip

  \item Pro každé $p: A \rightarrow v, g(p) \in P$,  kde $v=b_0 B_1 b_1 B_2 b_2 \dots b_{j-1} B_{j} b_j$, $j \in \{0,1,2,3,\dots,n\}$, $b_0,b_i \in T^*$ a $B_i \in N$ pro všechna $i \in \{1,2,\dots,j\}$ : \medskip
  \subitem Pro každé $(k,u,z) \in \{1,2,3,\dots,n-j+1\} \times N^* \times N^*$, kde $|u| = k-1$, $|z|  \le n-k$ : \medskip
  \subsubitem Pokud $g(p) = \emptyset$ :
  \subsubitem přidej do $Q$ stavy $<p,uAz>$, $<\varepsilon, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R$ pravidlo $<p,uAz>_k \# \rightarrow <\varepsilon, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j$.\medskip
  \subsubitem Jinak pro každé $q \in g(p)$:
  \subsubitem přidej do $Q$ stavy $<p,uAz>$, $<q, u B_1 B_2 \dots B_{j-1} B_{j} z>$,
  \subsubitem přidej do $R$ pravidlo $<p,uAz>_k \# \rightarrow <q, u B_1 B_2 \dots B_{j-1} B_{j} z> b_0 \# b_1 \# b_2 \dots b_{j-1} \# b_j$.

\end{list}
\end{Alg}

Konstrukce důkazu o~převodu hlubokého zásobníkového automatu konečného indexu s~jedním nevstupním symbolem na programovou gramatiku konečného indexu je dohledatelná ve článku \cite{Krivka:RewritingSystems}, který srovnává programové gramatiky s~\#-Rewriting Systems. Programová gramatika simuluje každý krok zásobníkového automatu sekvencí několika derivací. Neterminály obsahují informace o~stavu zásobníku, aktuální pozici výskytu symbolu \# a celkovém počtu všech \# v~aktuální konfiguraci. Vlastní simulace probíhá následovně:

\begin{list}{}{\setlength\parsep{0cm} \setlength\itemsep{0cm} \setlength\leftmargin{1em}}
\item 1. Aktualizace pozice a celkového počtu nevstupních symbolů u~všech neterminálů.
\item 2. Expanze neterminálu na příslušné pozici.
\item 3. Odstranění pomocných stavů.
\end{list}

Tím jsem ukázala, že výše zavedený typ zásobníkového automatu je ekvivalentní s~programovými gramatikami. Z~toho vyplývá, že rodina jazyků přijímaná tímto zásobníkovým automatem tvoří nekonečnou hierarchii vycházející z~programových gramatik.


%=========================================================================
